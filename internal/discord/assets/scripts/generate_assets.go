package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const (
	mapGalleryUrl = "https://mapgallery.realitymod.com"
	levelsJsonUrl = mapGalleryUrl + "/json/levels.json"
	tileUrlFmt    = mapGalleryUrl + "/images/maps/%s/tile.jpg"
)

const goTemplate = `// Code generated by go generate; DO NOT EDIT. 
package discord

var levels = map[string]level{
{{- range .}}
	"{{.Key}}": {Name: "{{.Name}}", Key: "{{.Key}}", Size: {{.Size}}},
{{- end}}
}
`

type level struct {
	Name string `json:"Name"`
	Key  string `json:"Key"`
	Size int    `json:"Size"`
}

var (
	assetsPathFlag string
)

func main() {
	flag.StringVar(&assetsPathFlag, "assets-path", "./", "Path to the assets directory")
	flag.Parse()

	if err := run(assetsPathFlag); err != nil {
		panic(err)
	}
}

func run(path string) error {
	httpClient := &http.Client{}

	resp, err := httpClient.Get(levelsJsonUrl)
	if err != nil {
		return err
	}

	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to fetch maps: status code %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	var levels []level
	err = json.Unmarshal(body, &levels)
	if err != nil {
		return err
	}

	if err := generateLevelsGo(path, levels); err != nil {
		return err
	}

	for _, lvl := range levels {
		if err := fetchTile(httpClient, path, lvl.Name); err != nil {
			return err
		}
	}

	return nil
}

func generateLevelsGo(path string, levels []level) error {
	// Create template
	tmpl, err := template.New("levels").Parse(goTemplate)
	if err != nil {
		return err
	}

	// Create output file
	file, err := os.Create(filepath.Join(path, "levels_generated.go"))
	if err != nil {
		return err
	}
	defer file.Close()

	// Execute template
	if err := tmpl.Execute(file, levels); err != nil {
		return err
	}

	return nil
}

func fetchTile(httpClient *http.Client, path, name string) error {
	key := getKey(name)

	stat, err := os.Stat(filepath.Join(path, "assets", "tiles", key+".jpg"))
	if err == nil && stat.Size() > 0 {
		return nil
	}

	url := fmt.Sprintf(tileUrlFmt, key)
	resp, err := httpClient.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to fetch map tile: status code %d", resp.StatusCode)
	}

	outFile, err := os.Create(filepath.Join(path, "assets", "tiles", key+".jpg"))
	if err != nil {
		return err
	}
	defer outFile.Close()

	_, err = io.Copy(outFile, resp.Body)
	return err
}

func getKey(t string) string {
	// Remove all spaces and underscores
	re := regexp.MustCompile(`[ _]`)
	cleaned := re.ReplaceAllString(t, "")
	// Convert to lowercase
	return strings.ToLower(cleaned)
}
